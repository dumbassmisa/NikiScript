// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace NikiScript
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void CommandCallbackFn(__IntPtr pCtx, __IntPtr pData);

    public unsafe partial class Command : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C description;
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ argsDescriptions;
            internal byte minArgs;
            internal byte maxArgs;
            internal __IntPtr callback;
            internal __IntPtr pData;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Command@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Command@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1Command@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?printAsDataTree@Command@ns@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrintAsDataTree(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getArgumentsNames@Command@ns@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetArgumentsNames(__IntPtr __instance, __IntPtr @return);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Command> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Command>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.Command managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.Command managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Command __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Command(native.ToPointer(), skipVTables);
        }

        internal static Command __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Command)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Command __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Command(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.Command.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Command(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Command(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Command()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Command.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public Command(global::NikiScript.Command _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Command.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>prints usage, description and argsDescriptions all like a data tree</summary>
        public void PrintAsDataTree()
        {
            __Internal.PrintAsDataTree(__Instance);
        }

        public string Name
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->name));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->name), value);
            }
        }

        public string Description
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->description));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->description), value);
            }
        }

        public byte MinArgs
        {
            get
            {
                return ((__Internal*)__Instance)->minArgs;
            }

            set
            {
                ((__Internal*)__Instance)->minArgs = value;
            }
        }

        public byte MaxArgs
        {
            get
            {
                return ((__Internal*)__Instance)->maxArgs;
            }

            set
            {
                ((__Internal*)__Instance)->maxArgs = value;
            }
        }

        public global::NikiScript.CommandCallbackFn Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::NikiScript.CommandCallbackFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::NikiScript.CommandCallbackFn));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>pData is useful for functions that don't have a defined body and actually depends on a data that it's not possible to know without a hacky way which is worse than just using pData</summary>
        public __IntPtr PData
        {
            get
            {
                return ((__Internal*)__Instance)->pData;
            }

            set
            {
                ((__Internal*)__Instance)->pData = (__IntPtr) value;
            }
        }

        /// <summary>splitted by space</summary>
        public string ArgumentsNames
        {
            get
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetArgumentsNames(__Instance, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }
        }
    }

    public unsafe partial class CommandHandler : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::Std.UnorderedMap.__Internalc__N_std_S_unordered_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ commands;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0CommandHandler@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0CommandHandler@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1CommandHandler@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?get@CommandHandler@ns@@QEAAPEAUCommand@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get(__IntPtr __instance, __IntPtr name);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?add@CommandHandler@ns@@QEAA_NAEBUCommand@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Add(__IntPtr __instance, __IntPtr command);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?remove@CommandHandler@ns@@QEAAXPEAUCommandContext@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Remove(__IntPtr __instance, __IntPtr pCtx, __IntPtr name);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.CommandHandler> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.CommandHandler>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.CommandHandler managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.CommandHandler managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CommandHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CommandHandler(native.ToPointer(), skipVTables);
        }

        internal static CommandHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CommandHandler)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CommandHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CommandHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.CommandHandler.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CommandHandler(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CommandHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CommandHandler(global::NikiScript.CommandHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.CommandHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public CommandHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.CommandHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NikiScript.Command Get(string name)
        {
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, name);
            var __arg0 = __basicString0.__Instance;
            var ___ret = __Internal.Get(__Instance, __arg0);
            __basicString0.Dispose();
            var __result0 = global::NikiScript.Command.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>adds command to commands unordered_map</summary>
        /// <param name="command">name of the will be mapped in the commands variable</param>
        /// <returns>true if command name is okay</returns>
        /// <returns>false if command with this name already exists</returns>
        public bool Add(global::NikiScript.Command command)
        {
            if (ReferenceEquals(command, null))
                throw new global::System.ArgumentNullException("command", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = command.__Instance;
            var ___ret = __Internal.Add(__Instance, __arg0);
            return ___ret;
        }

        public void Remove(global::NikiScript.CommandContext pCtx, string name)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, name);
            var __arg1 = __basicString1.__Instance;
            __Internal.Remove(__Instance, __arg0, __arg1);
            __basicString1.Dispose();
        }
    }

    [Flags]
    public enum OriginType : ushort
    {
        /// <summary>If a command is calling another command.</summary>
        COMMAND = 1,
        /// <summary>Any variable.</summary>
        VARIABLE = 2,
        /// <summary>Var x that calls var y.</summary>
        VARIABLE_IN_VARIABLE = 4,
        /// <summary>'!'.</summary>
        VARIABLE_LOOP = 8,
        /// <summary>'+' or '-'.</summary>
        VARIABLE_TOGGLE = 16,
        /// <summary>ns::parseFile or exec command.</summary>
        FILE = 32,
        /// <summary>Raw script generated from C++ code and not from a file or variable or anything else.</summary>
        INTERNAL = 64,
        /// <summary>Scripts ran inside a reference ${echo hello} -&gt; echo command is ran inside a reference and its output is the reference result.</summary>
        REFERENCE = 128
    }

    public unsafe partial class Arguments : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ arguments;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Arguments@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Arguments@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1Arguments@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getString@Arguments@ns@@QEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetString(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getFloat@Arguments@ns@@QEAAM_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetFloat(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getDouble@Arguments@ns@@QEAAN_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double GetDouble(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getByte@Arguments@ns@@QEAAE_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte GetByte(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getUInt16@Arguments@ns@@QEAAG_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetUInt16(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getUInt32@Arguments@ns@@QEAAI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetUInt32(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getUInt64@Arguments@ns@@QEAA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GetUInt64(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getSByte@Arguments@ns@@QEAAC_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte GetSByte(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getInt16@Arguments@ns@@QEAAF_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern short GetInt16(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getInt32@Arguments@ns@@QEAAH_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetInt32(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getInt64@Arguments@ns@@QEAA_J_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long GetInt64(__IntPtr __instance, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?count@Arguments@ns@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong Count(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Arguments> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Arguments>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.Arguments managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.Arguments managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Arguments __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Arguments(native.ToPointer(), skipVTables);
        }

        internal static Arguments __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Arguments)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Arguments __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Arguments(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.Arguments.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Arguments(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Arguments(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Arguments(global::NikiScript.Arguments _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Arguments.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public Arguments()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Arguments.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string GetString(ulong index)
        {
            var ___ret = __Internal.GetString(__Instance, index);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(___ret);
            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
        }

        public float GetFloat(ulong index)
        {
            var ___ret = __Internal.GetFloat(__Instance, index);
            return ___ret;
        }

        public double GetDouble(ulong index)
        {
            var ___ret = __Internal.GetDouble(__Instance, index);
            return ___ret;
        }

        public byte GetByte(ulong index)
        {
            var ___ret = __Internal.GetByte(__Instance, index);
            return ___ret;
        }

        public ushort GetUInt16(ulong index)
        {
            var ___ret = __Internal.GetUInt16(__Instance, index);
            return ___ret;
        }

        public uint GetUInt32(ulong index)
        {
            var ___ret = __Internal.GetUInt32(__Instance, index);
            return ___ret;
        }

        public ulong GetUInt64(ulong index)
        {
            var ___ret = __Internal.GetUInt64(__Instance, index);
            return ___ret;
        }

        public sbyte GetSByte(ulong index)
        {
            var ___ret = __Internal.GetSByte(__Instance, index);
            return ___ret;
        }

        public short GetInt16(ulong index)
        {
            var ___ret = __Internal.GetInt16(__Instance, index);
            return ___ret;
        }

        public int GetInt32(ulong index)
        {
            var ___ret = __Internal.GetInt32(__Instance, index);
            return ___ret;
        }

        public long GetInt64(ulong index)
        {
            var ___ret = __Internal.GetInt64(__Instance, index);
            return ___ret;
        }

        public ulong Count
        {
            get
            {
                var ___ret = __Internal.Count(__Instance);
                return ___ret;
            }
        }
    }

    /// <summary>General context that can be used with multiple command contexts.</summary>
    public unsafe partial class Context : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 280)]
        public partial struct __Internal
        {
            internal global::Std.UnorderedMap.__Internalc__N_std_S_unordered_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S0____N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S0_ consoleVariables;
            internal global::Std.UnorderedMap.__Internalc__N_std_S_unordered_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ programVariables;
            internal global::NikiScript.CommandHandler.__Internal commands;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S2____N_std_S_allocator__S0_ loopVariablesRunning;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S2____N_std_S_allocator__S0_ toggleVariablesRunning;
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_ns_S_Command___N_std_S_allocator__S0_ toggleCommandsRunning;
            internal ushort maxConsoleVariablesRecursiveDepth;
            internal __IntPtr cfgDirectory;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Context@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Context@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1Context@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Context> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Context>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.Context managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.Context managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __cfgDirectory_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static Context __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Context(native.ToPointer(), skipVTables);
        }

        internal static Context __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Context)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Context __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Context(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.Context.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Context(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Context(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Context(global::NikiScript.Context _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Context.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public Context()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Context.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__cfgDirectory_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->cfgDirectory);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::NikiScript.CommandHandler Commands
        {
            get
            {
                return global::NikiScript.CommandHandler.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->commands));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->commands = *(global::NikiScript.CommandHandler.__Internal*) value.__Instance;
            }
        }

        /// <summary>How many console variables can be called inside each other</summary>
        public ushort MaxConsoleVariablesRecursiveDepth
        {
            get
            {
                return ((__Internal*)__Instance)->maxConsoleVariablesRecursiveDepth;
            }

            set
            {
                ((__Internal*)__Instance)->maxConsoleVariablesRecursiveDepth = value;
            }
        }

        /// <summary>Expects a null terminated char array. Heap allocated is possible but this code doesn't free by itself</summary>
        public string CfgDirectory
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->cfgDirectory);
            }

            set
            {
                if (__cfgDirectory_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->cfgDirectory);
                __cfgDirectory_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->cfgDirectory = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->cfgDirectory = (__IntPtr) __bytePtr0;
            }
        }
    }

    /// <summary>Context passed to commands callbacks which contains command required data.</summary>
    public unsafe partial class CommandContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 208)]
        public partial struct __Internal
        {
            internal __IntPtr pCtx;
            internal __IntPtr pCommand;
            internal global::NikiScript.Lexer.__Internal lexer;
            internal global::NikiScript.Arguments.__Internal args;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C filePath;
            internal ulong lineCount;
            internal ushort origin;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0CommandContext@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0CommandContext@ns@@QEAA@PEAUContext@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr pCtx);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0CommandContext@ns@@QEAA@PEAUContext@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr pCtx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string lexerInput);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0CommandContext@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1CommandContext@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.CommandContext> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.CommandContext>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.CommandContext managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.CommandContext managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CommandContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CommandContext(native.ToPointer(), skipVTables);
        }

        internal static CommandContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CommandContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CommandContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CommandContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.CommandContext.__Internal.cctor_1(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private CommandContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CommandContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CommandContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.CommandContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public CommandContext(global::NikiScript.Context pCtx)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.CommandContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.ctor(__Instance, __arg0);
        }

        public CommandContext(global::NikiScript.Context pCtx, string lexerInput)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.CommandContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.ctor(__Instance, __arg0, lexerInput);
        }

        public CommandContext(global::NikiScript.CommandContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.CommandContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::NikiScript.CommandContext(global::NikiScript.Context pCtx)
        {
            return new global::NikiScript.CommandContext(pCtx);
        }

        /// <summary>A general context which contains data which commands won't need unless for special cases.</summary>
        public global::NikiScript.Context PCtx
        {
            get
            {
                var __result0 = global::NikiScript.Context.__GetOrCreateInstance(((__Internal*)__Instance)->pCtx, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->pCtx = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::NikiScript.Command PCommand
        {
            get
            {
                var __result0 = global::NikiScript.Command.__GetOrCreateInstance(((__Internal*)__Instance)->pCommand, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->pCommand = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::NikiScript.Lexer Lexer
        {
            get
            {
                return global::NikiScript.Lexer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->lexer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->lexer = *(global::NikiScript.Lexer.__Internal*) value.__Instance;
            }
        }

        public global::NikiScript.Arguments Args
        {
            get
            {
                return global::NikiScript.Arguments.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->args));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->args = *(global::NikiScript.Arguments.__Internal*) value.__Instance;
            }
        }

        /// <summary>when running script from a file.</summary>
        public string FilePath
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->filePath));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->filePath), value);
            }
        }

        public ulong LineCount
        {
            get
            {
                return ((__Internal*)__Instance)->lineCount;
            }

            set
            {
                ((__Internal*)__Instance)->lineCount = value;
            }
        }

        /// <summary>this is used so that the command knows where he's running in. See ns::OriginType.</summary>
        public ushort Origin
        {
            get
            {
                return ((__Internal*)__Instance)->origin;
            }

            set
            {
                ((__Internal*)__Instance)->origin = value;
            }
        }
    }

    public unsafe partial class Context
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?deepCopyContext@ns@@YA?AUContext@1@PEBU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DeepCopyContext(__IntPtr @return, __IntPtr source);
        }

        /// <summary>
        /// <para>If you want a 100% new copy without being dependent on the source context then use this function.</para>
        /// <para>LoopVariablesRunning and ToggleVariablesRunning stores pointers</para>
        /// <para>to ConsoleVariables as well as toggleCommandsRunning whose</para>
        /// <para>pointers are from CommandHandler. That's why this function exists:</para>
        /// <para>It updates all those pointers.</para>
        /// </summary>
        /// <param name="source">Object to copy content from.</param>
        public static global::NikiScript.Context DeepCopyContext(global::NikiScript.Context source)
        {
            var __arg0 = source is null ? __IntPtr.Zero : source.__Instance;
            var ___ret = new global::NikiScript.Context.__Internal();
            __Internal.DeepCopyContext(new IntPtr(&___ret), __arg0);
            var _____ret = global::NikiScript.Context.__CreateInstance(___ret);
            global::NikiScript.Context.__Internal.dtor(new __IntPtr(&___ret));
            return _____ret;
        }
    }

    public unsafe partial class Utils
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?isSpaceNotNewline@ns@@YA_NE@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSpaceNotNewline(byte c);
        }

        /// <summary>call isspace but does not accept newline</summary>
        /// <param name="c">char to check if is space</param>
        /// <returns>true if is space</returns>
        /// <returns>false if is not space</returns>
        public static bool IsSpaceNotNewline(byte c)
        {
            var ___ret = __Internal.IsSpaceNotNewline(c);
            return ___ret;
        }
    }

    public enum PrintLevel : byte
    {
        /// <summary>any text that came from a command that is not an error</summary>
        ECHO = 0,
        /// <summary>anything that is wrong but can continue</summary>
        WARNING = 1,
        /// <summary>anything that went wrong and can not continue</summary>
        ERROR = 2
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PrintCallbackFn(__IntPtr pData, global::NikiScript.PrintLevel level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message);

    public unsafe partial class Print
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setPrintCallback@ns@@YAXPEAXP6AX0W4PrintLevel@1@PEBD@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetPrintCallback(__IntPtr pData, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?print@ns@@YAXW4PrintLevel@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Print(global::NikiScript.PrintLevel level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?printUnknownCommand@ns@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrintUnknownCommand([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string command);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?printAppendToStringEchoOnly@ns@@YAXPEAXW4PrintLevel@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrintAppendToStringEchoOnly(__IntPtr pBuffer, global::NikiScript.PrintLevel level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string);
        }

        public static void SetPrintCallback(__IntPtr pData, global::NikiScript.PrintCallbackFn callback)
        {
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SetPrintCallback(pData, __arg1);
        }

        public static void Print_(global::NikiScript.PrintLevel level, string str)
        {
            __Internal.Print(level, str);
        }

        public static void PrintUnknownCommand(string command)
        {
            __Internal.PrintUnknownCommand(command);
        }

        /// <summary>appends string to pBuffer if level is PrintLevel::ECHO</summary>
        /// <param name="pBuffer">should be std::string*</param>
        /// <param name="level">should be ECHO to be appended to the string</param>
        /// <param name="string">string to append to pBuffer</param>
        public static void PrintAppendToStringEchoOnly(__IntPtr pBuffer, global::NikiScript.PrintLevel level, string @string)
        {
            __Internal.PrintAppendToStringEchoOnly(pBuffer, level, @string);
        }

        public static global::NikiScript.PrintCallbackFn PrintCallback
        {
            get
            {
                var __ptr = (__IntPtr*)global::NikiScript.__Symbols.NikiScript._printCallback_ns__3P6AXPEAXW4PrintLevel_1_PEBD_ZEA;
                var __ptr0 = *(__IntPtr*)(*__ptr);
                return __ptr0 == IntPtr.Zero? null : (global::NikiScript.PrintCallbackFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::NikiScript.PrintCallbackFn));
            }

            set
            {
                var __ptr = (__IntPtr*)global::NikiScript.__Symbols.NikiScript._printCallback_ns__3P6AXPEAXW4PrintLevel_1_PEBD_ZEA;
                *__ptr = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public static __IntPtr PPrintCallbackData
        {
            get
            {
                var __ptr = (__IntPtr*)global::NikiScript.__Symbols.NikiScript._pPrintCallbackData_ns__3PEAXEA;
                return *(__IntPtr*)(*__ptr);
            }

            set
            {
                var __ptr = (__IntPtr*)global::NikiScript.__Symbols.NikiScript._pPrintCallbackData_ns__3PEAXEA;
                *__ptr = value;
            }
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C GetProgramVariableValueFn(__IntPtr pCtx, __IntPtr pVar);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SetProgramVariableValueFn(__IntPtr pCtx, __IntPtr pVar, __IntPtr str);

    public unsafe partial class ProgramVariable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr pValue;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C description;
            internal __IntPtr get;
            internal __IntPtr set;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0ProgramVariable@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0ProgramVariable@ns@@QEAA@PEAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBQ6A?AV23@PEAUCommandContext@1@PEAU01@@ZAEBQ6AX231@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr pValue, __IntPtr description, __IntPtr get, __IntPtr set);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0ProgramVariable@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1ProgramVariable@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.ProgramVariable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.ProgramVariable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.ProgramVariable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.ProgramVariable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ProgramVariable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ProgramVariable(native.ToPointer(), skipVTables);
        }

        internal static ProgramVariable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ProgramVariable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ProgramVariable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ProgramVariable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.ProgramVariable.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ProgramVariable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ProgramVariable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ProgramVariable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.ProgramVariable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public ProgramVariable(__IntPtr pValue, string description, global::NikiScript.GetProgramVariableValueFn get, global::NikiScript.SetProgramVariableValueFn set)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.ProgramVariable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, description);
            var __arg1 = __basicString1.__Instance;
            var __arg2 = get == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(get);
            var __arg3 = set == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(set);
            __Internal.ctor(__Instance, pValue, __arg1, __arg2, __arg3);
            __basicString1.Dispose();
        }

        public ProgramVariable(global::NikiScript.ProgramVariable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.ProgramVariable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr PValue
        {
            get
            {
                return ((__Internal*)__Instance)->pValue;
            }

            set
            {
                ((__Internal*)__Instance)->pValue = (__IntPtr) value;
            }
        }

        public string Description
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->description));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->description), value);
            }
        }

        public global::NikiScript.GetProgramVariableValueFn Get
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get;
                return __ptr0 == IntPtr.Zero? null : (global::NikiScript.GetProgramVariableValueFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::NikiScript.GetProgramVariableValueFn));
            }

            set
            {
                ((__Internal*)__Instance)->get = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::NikiScript.SetProgramVariableValueFn Set
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set;
                return __ptr0 == IntPtr.Zero? null : (global::NikiScript.SetProgramVariableValueFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::NikiScript.SetProgramVariableValueFn));
            }

            set
            {
                ((__Internal*)__Instance)->set = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ProgramVariable
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getString@ns@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUCommandContext@1@PEAUProgramVariable@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetString(__IntPtr @return, __IntPtr _0, __IntPtr pVar);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setString@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetString(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?getCharArray@ns@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUCommandContext@1@PEAUProgramVariable@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetCharArray(__IntPtr @return, __IntPtr _0, __IntPtr pVar);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setUnsignedLongLong@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetUnsignedLongLong(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setFloat@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetFloat(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setDouble@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetDouble(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setLongDouble@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetLongDouble(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setChar@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetChar(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setShort@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetShort(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setInteger@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInteger(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setLong@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetLong(__IntPtr _0, __IntPtr pVar, __IntPtr str);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setLongLong@ns@@YAXPEAUCommandContext@1@PEAUProgramVariable@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetLongLong(__IntPtr _0, __IntPtr pVar, __IntPtr str);
        }

        public static string GetString(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.GetString(new IntPtr(&___ret), __arg0, __arg1);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
            var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            __basicStringRet0.Dispose();
            return __retString0;
        }

        public static void SetString(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetString(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static string GetCharArray(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.GetCharArray(new IntPtr(&___ret), __arg0, __arg1);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
            var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            __basicStringRet0.Dispose();
            return __retString0;
        }

        public static void SetUnsignedLongLong(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetUnsignedLongLong(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetFloat(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetFloat(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetDouble(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetDouble(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetLongDouble(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetLongDouble(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetChar(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetChar(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetShort(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetShort(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetInteger(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetInteger(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetLong(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetLong(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }

        public static void SetLongLong(global::NikiScript.CommandContext _0, global::NikiScript.ProgramVariable pVar, string str)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg1 = pVar is null ? __IntPtr.Zero : pVar.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, str);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetLongLong(__arg0, __arg1, __arg2);
            __basicString2.Dispose();
        }
    }

    [Flags]
    public enum TokenType : byte
    {
        NONE = 0,
        /// <summary>If it's the first token after an EOS, END or NONE. Should be either a variable or command</summary>
        IDENTIFIER = 1,
        /// <summary>If lexer could not convert to integer and an identifier was already caught up</summary>
        ARGUMENT = 2,
        /// <summary>End Of Statement</summary>
        EOS = 4,
        /// <summary>End of input data</summary>
        END = 8
    }

    public unsafe partial class Token : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::NikiScript.TokenType type;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C value;
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_pair__k___N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ references;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Token@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Token@ns@@QEAA@W4TokenType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, global::NikiScript.TokenType type);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Token@ns@@QEAA@W4TokenType@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, global::NikiScript.TokenType type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Token@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1Token@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Token> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Token>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.Token managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.Token managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Token __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Token(native.ToPointer(), skipVTables);
        }

        internal static Token __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Token)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Token __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Token(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.Token.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Token(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Token(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Token()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Token.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public Token(global::NikiScript.TokenType type)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Token.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, type);
        }

        public Token(global::NikiScript.TokenType type, string value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Token.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, type, value);
        }

        public Token(global::NikiScript.Token _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Token.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::NikiScript.Token(global::NikiScript.TokenType type)
        {
            return new global::NikiScript.Token(type);
        }

        public global::NikiScript.TokenType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public string Value
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->value));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->value), value);
            }
        }
    }

    public unsafe partial class Token
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?insertReferencesInToken@ns@@YAXPEAUCommandContext@1@AEAUToken@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void InsertReferencesInToken(__IntPtr pCtx, __IntPtr token);
        }

        /// <summary>inserts all references in the value</summary>
        public static void InsertReferencesInToken(global::NikiScript.CommandContext pCtx, global::NikiScript.Token token)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            if (ReferenceEquals(token, null))
                throw new global::System.ArgumentNullException("token", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = token.__Instance;
            __Internal.InsertReferencesInToken(__arg0, __arg1);
        }
    }

    public unsafe partial class Lexer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 120)]
        public partial struct __Internal
        {
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C input;
            internal ulong position;
            internal ulong openArguments;
            internal ulong lineIndex;
            internal global::NikiScript.Token.__Internal token;

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Lexer@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Lexer@ns@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??0Lexer@ns@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "??1Lexer@ns@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?advance@Lexer@ns@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Advance(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?advanceUntil@Lexer@ns@@QEAAXE@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AdvanceUntil(__IntPtr __instance, byte flags);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setTokenValue@Lexer@ns@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetTokenValue(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?setTokenType@Lexer@ns@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetTokenType(__IntPtr __instance, bool skipStatementSeparator);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?clear@Lexer@ns@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Lexer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NikiScript.Lexer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NikiScript.Lexer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NikiScript.Lexer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Lexer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Lexer(native.ToPointer(), skipVTables);
        }

        internal static Lexer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Lexer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Lexer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Lexer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::NikiScript.Lexer.__Internal.cctor_1(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Lexer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Lexer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Lexer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Lexer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public Lexer(string input)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Lexer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, input);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor(__Instance, __arg0);
            __basicString0.Dispose();
        }

        public Lexer(global::NikiScript.Lexer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NikiScript.Lexer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the next token in the input</summary>
        /// <remarks>
        /// <para>Position is set to the **next** token position in the end of this function</para>
        /// <para>Lexer::token</para>
        /// <para>Lexer::setTokenValue</para>
        /// <para>Lexer::setTokenType</para>
        /// </remarks>
        public void Advance()
        {
            __Internal.Advance(__Instance);
        }

        /// <summary>Advances tokens until it reaches one of the flags</summary>
        /// <param name="flags">Bitwise TokenType</param>
        /// <remarks>Lexer::advance</remarks>
        public void AdvanceUntil(byte flags)
        {
            __Internal.AdvanceUntil(__Instance, flags);
        }

        /// <summary>Gets token value by checking where a whitespace is found and updates token position to the end+1 of the new token</summary>
        /// <returns>true if it NS_STATEMENT_SEPARATOR but inside a string and therefore should not be interpreted as such</returns>
        /// <remarks>Lexer::setTokenType</remarks>
        public bool SetTokenValue()
        {
            var ___ret = __Internal.SetTokenValue(__Instance);
            return ___ret;
        }

        /// <summary>Identifies token type by checking the previous token type</summary>
        /// <remarks>Lexer::setTokenValue</remarks>
        public void SetTokenType(bool skipStatementSeparator)
        {
            __Internal.SetTokenType(__Instance, skipStatementSeparator);
        }

        /// <summary>resets members</summary>
        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public static implicit operator global::NikiScript.Lexer(string input)
        {
            return new global::NikiScript.Lexer(input);
        }

        public string Input
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->input));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->input), value);
            }
        }

        public ulong Position
        {
            get
            {
                return ((__Internal*)__Instance)->position;
            }

            set
            {
                ((__Internal*)__Instance)->position = value;
            }
        }

        /// <summary>how many times NS_ARGUMENTS_OPEN was found</summary>
        public ulong OpenArguments
        {
            get
            {
                return ((__Internal*)__Instance)->openArguments;
            }

            set
            {
                ((__Internal*)__Instance)->openArguments = value;
            }
        }

        /// <summary>how many newlines were found basically</summary>
        public ulong LineIndex
        {
            get
            {
                return ((__Internal*)__Instance)->lineIndex;
            }

            set
            {
                ((__Internal*)__Instance)->lineIndex = value;
            }
        }

        /// <summary>This variable is where advance stores the token</summary>
        /// <remarks>Lexer::advance</remarks>
        public global::NikiScript.Token Token
        {
            get
            {
                return global::NikiScript.Token.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->token));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->token = *(global::NikiScript.Token.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class NikiScript
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?help@ns@@YAXPEAUCommandContext@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Help(__IntPtr pCtx, __IntPtr name);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?help_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HelpCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?echo_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void EchoCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?var@ns@@YA_NPEAUCommandContext@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Var(__IntPtr pCtx, __IntPtr name, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?var_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void VarCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?delvar@ns@@YAXPEAUCommandContext@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Delvar(__IntPtr pCtx, __IntPtr name);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?delvar_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DelvarCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?incrementvar@ns@@YAXPEAUCommandContext@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Incrementvar(__IntPtr pCtx, __IntPtr name, float min, float max, float delta);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?incrementvar_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void IncrementvarCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?toggle@ns@@YAXPEAUCommandContext@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Toggle(__IntPtr pCtx, __IntPtr varName, __IntPtr option1, __IntPtr option2);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?toggle_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ToggleCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?exec_command@ns@@YAXPEAUCommandContext@1@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ExecCommand(__IntPtr pCtx, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?registerCommands@ns@@YAXPEAUContext@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RegisterCommands(__IntPtr pCtx);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?registerVariable@ns@@YAXPEAUContext@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PEAXAEBQ6A?AV34@PEAUCommandContext@1@PEAUProgramVariable@1@@ZAEBQ6AX341@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RegisterVariable(__IntPtr pCtx, __IntPtr name, __IntPtr description, __IntPtr pVar, __IntPtr get, __IntPtr set);
        }

        public static void Help(global::NikiScript.CommandContext pCtx, string name)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, name);
            var __arg1 = __basicString1.__Instance;
            __Internal.Help(__arg0, __arg1);
            __basicString1.Dispose();
        }

        /// <summary>shows command usage</summary>
        /// <remarks>s[command?]</remarks>
        public static void HelpCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.HelpCommand(__arg0, _0);
        }

        /// <summary>prints all the arguments passed</summary>
        /// <remarks>s[message]</remarks>
        public static void EchoCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.EchoCommand(__arg0, _0);
        }

        /// <summary>creates a variable</summary>
        /// <returns>true on success</returns>
        /// <remarks>if origin contains OriginType::REFERENCE then it will not print errors</remarks>
        public static bool Var(global::NikiScript.CommandContext pCtx, string name, string value)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, name);
            var __arg1 = __basicString1.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, value);
            var __arg2 = __basicString2.__Instance;
            var ___ret = __Internal.Var(__arg0, __arg1, __arg2);
            __basicString1.Dispose();
            __basicString2.Dispose();
            return ___ret;
        }

        /// <summary>creates a variable</summary>
        /// <remarks>
        /// <para>s[name] s[value]</para>
        /// <para>ns::var</para>
        /// </remarks>
        public static void VarCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.VarCommand(__arg0, _0);
        }

        public static void Delvar(global::NikiScript.CommandContext pCtx, string name)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, name);
            var __arg1 = __basicString1.__Instance;
            __Internal.Delvar(__arg0, __arg1);
            __basicString1.Dispose();
        }

        /// <summary>deletes a variable</summary>
        /// <remarks>
        /// <para>v[consoleVariable]</para>
        /// <para>ns::delvar</para>
        /// </remarks>
        public static void DelvarCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.DelvarCommand(__arg0, _0);
        }

        public static void Incrementvar(global::NikiScript.CommandContext pCtx, string name, float min, float max, float delta)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, name);
            var __arg1 = __basicString1.__Instance;
            __Internal.Incrementvar(__arg0, __arg1, min, max, delta);
            __basicString1.Dispose();
        }

        /// <summary>increments a variable value</summary>
        /// <remarks>
        /// <para>v[variable] d[min] d[max] d[delta?]</para>
        /// <para>ns::incrementvar</para>
        /// </remarks>
        public static void IncrementvarCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.IncrementvarCommand(__arg0, _0);
        }

        /// <summary>toggles a variable value between option1 and option2</summary>
        public static void Toggle(global::NikiScript.CommandContext pCtx, string varName, string option1, string option2)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, varName);
            var __arg1 = __basicString1.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, option1);
            var __arg2 = __basicString2.__Instance;
            var __basicString3 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString3, option2);
            var __arg3 = __basicString3.__Instance;
            __Internal.Toggle(__arg0, __arg1, __arg2, __arg3);
            __basicString1.Dispose();
            __basicString2.Dispose();
            __basicString3.Dispose();
        }

        /// <summary>toggles a variable value between option1 and option2</summary>
        /// <remarks>
        /// <para>v[variable] s[option1] s[option2]</para>
        /// <para>ns::toggle</para>
        /// </remarks>
        public static void ToggleCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.ToggleCommand(__arg0, _0);
        }

        /// <summary>parses a file as nikiscript</summary>
        /// <remarks>
        /// <para>s[filePath]</para>
        /// <para>ns::parseFile</para>
        /// </remarks>
        public static void ExecCommand(global::NikiScript.CommandContext pCtx, __IntPtr _0)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.ExecCommand(__arg0, _0);
        }

        /// <summary>adds default commands such as echo</summary>
        /// <remarks>ns::echo_command</remarks>
        public static void RegisterCommands(global::NikiScript.Context pCtx)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.RegisterCommands(__arg0);
        }

        /// <summary>creates a variable and stores it in ns::Context::programVariables</summary>
        public static void RegisterVariable(global::NikiScript.Context pCtx, string name, string description, __IntPtr pVar, global::NikiScript.GetProgramVariableValueFn get, global::NikiScript.SetProgramVariableValueFn set)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString1, name);
            var __arg1 = __basicString1.__Instance;
            var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString2, description);
            var __arg2 = __basicString2.__Instance;
            var __arg4 = get == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(get);
            var __arg5 = set == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(set);
            __Internal.RegisterVariable(__arg0, __arg1, __arg2, pVar, __arg4, __arg5);
            __basicString1.Dispose();
            __basicString2.Dispose();
        }
    }

    public unsafe partial class Parser
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?clearStatementData@ns@@YAXPEAUCommandContext@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearStatementData(__IntPtr pCtx);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?canRunVariable@ns@@YA_NPEAUCommandContext@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CanRunVariable(__IntPtr pCtx);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?handleCommandCall@ns@@YAXPEAUCommandContext@1@AEAPEAUProgramVariable@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HandleCommandCall(__IntPtr pCtx, __IntPtr pProgramVar);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?handleIdentifierToken@ns@@YAEPEAUCommandContext@1@AEAPEAUProgramVariable@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte HandleIdentifierToken(__IntPtr pCtx, __IntPtr pProgramVar, bool printError);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?handleArgumentToken@ns@@YAXPEAUCommandContext@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HandleArgumentToken(__IntPtr pCtx, bool printError);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?handleConsoleVariableCall@ns@@YAXPEAUCommandContext@1@AEAPEAUProgramVariable@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HandleConsoleVariableCall(__IntPtr pCtx, __IntPtr pProgramVar, bool printError);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?updateLoopVariables@ns@@YAXPEAUContext@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UpdateLoopVariables(__IntPtr pCtx);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?parse@ns@@YAXPEAUCommandContext@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Parse(__IntPtr pCtx, bool printError);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?parseUntilEOS@ns@@YAXPEAUCommandContext@1@AEAPEAUProgramVariable@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ParseUntilEOS(__IntPtr pCtx, __IntPtr pProgramVar, bool printError);

            [SuppressUnmanagedCodeSecurity, DllImport("NikiScript", EntryPoint = "?parseFile@ns@@YA_NPEAUCommandContext@1@PEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ParseFile(__IntPtr pCtx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, bool printError);
        }

        /// <summary>Clear anything related to the current lexer statement</summary>
        /// <remarks>It does not go to the next EOS</remarks>
        public static void ClearStatementData(global::NikiScript.CommandContext pCtx)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.ClearStatementData(__arg0);
        }

        /// <summary>
        /// <para>if variable is a toggle variable and its allowed to run or if it's a common variable.</para>
        /// <para>It's also mandatory to call this function so that it updates those special variables</para>
        /// </summary>
        /// <remarks>
        /// <para>loop variables are only appended/erased from Context::LoopVariablesRunning</para>
        /// <para>ns::parse</para>
        /// <para>ns::handleIdentifierToken</para>
        /// </remarks>
        public static bool CanRunVariable(global::NikiScript.CommandContext pCtx)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var ___ret = __Internal.CanRunVariable(__arg0);
            return ___ret;
        }

        /// <summary>Called in parse function when EOS or END is reached</summary>
        /// <param name="pProgramVar">if not null: sets/gets program variable</param>
        /// <remarks>
        /// <para>Sets pCtx-&gt;pCommand to nullptr</para>
        /// <para>pCtx-&gt;pCommand should point to a valid Command object</para>
        /// <para>ns::parse</para>
        /// </remarks>
        public static void HandleCommandCall(global::NikiScript.CommandContext pCtx, global::NikiScript.ProgramVariable pProgramVar)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            if (ReferenceEquals(pProgramVar, null))
                throw new global::System.ArgumentNullException("pProgramVar", "Cannot be null because it is a C++ reference (&).");
            var ____arg1 = pProgramVar.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            __Internal.HandleCommandCall(__arg0, __arg1);
        }

        /// <summary>Called in parse function when IDENTIFIER token is passed</summary>
        /// <returns>0 = it called advanceUntil(EOS) 1 = should call lexer.advance() 2 = if it's a variable and should run it</returns>
        /// <remarks>
        /// <para>ns::parse</para>
        /// <para>ns::canRunVariable</para>
        /// </remarks>
        public static byte HandleIdentifierToken(global::NikiScript.CommandContext pCtx, global::NikiScript.ProgramVariable pProgramVar, bool printError)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            if (ReferenceEquals(pProgramVar, null))
                throw new global::System.ArgumentNullException("pProgramVar", "Cannot be null because it is a C++ reference (&).");
            var ____arg1 = pProgramVar.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.HandleIdentifierToken(__arg0, __arg1, printError);
            return ___ret;
        }

        /// <summary>Handles references in the string and checks if the parameter matches the argument type</summary>
        /// <remarks>
        /// <para>Possible argument types: s = string, i = integer, d = decimal, v = variable</para>
        /// <para>ns::parse</para>
        /// </remarks>
        public static void HandleArgumentToken(global::NikiScript.CommandContext pCtx, bool printError)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.HandleArgumentToken(__arg0, printError);
        }

        /// <summary>Called in parse function when an ConsoleVariable is passed as a IDENTIFIER</summary>
        /// <remarks>
        /// <para>I find this algorithm very interesting and fun(it creates a bunch of lexers for each variable call instead of recursive calling)</para>
        /// <para>ns::Context::maxConsoleVariablesRecursiveDepth</para>
        /// </remarks>
        public static void HandleConsoleVariableCall(global::NikiScript.CommandContext pCtx, global::NikiScript.ProgramVariable pProgramVar, bool printError)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            if (ReferenceEquals(pProgramVar, null))
                throw new global::System.ArgumentNullException("pProgramVar", "Cannot be null because it is a C++ reference (&).");
            var ____arg1 = pProgramVar.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            __Internal.HandleConsoleVariableCall(__arg0, __arg1, printError);
        }

        /// <summary>if a loop variable is active, its script is ran here</summary>
        public static void UpdateLoopVariables(global::NikiScript.Context pCtx)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.UpdateLoopVariables(__arg0);
        }

        /// <summary>Parses and interpret scripts: handles commands and variables as well as their arguments</summary>
        public static void Parse(global::NikiScript.CommandContext pCtx, bool printError)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            __Internal.Parse(__arg0, printError);
        }

        public static void ParseUntilEOS(global::NikiScript.CommandContext pCtx, global::NikiScript.ProgramVariable pProgramVar, bool printError)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            if (ReferenceEquals(pProgramVar, null))
                throw new global::System.ArgumentNullException("pProgramVar", "Cannot be null because it is a C++ reference (&).");
            var ____arg1 = pProgramVar.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            __Internal.ParseUntilEOS(__arg0, __arg1, printError);
        }

        public static bool ParseFile(global::NikiScript.CommandContext pCtx, string path, bool printError)
        {
            var __arg0 = pCtx is null ? __IntPtr.Zero : pCtx.__Instance;
            var ___ret = __Internal.ParseFile(__arg0, path, printError);
            return ___ret;
        }
    }
}

namespace NikiScript.__Symbols
{
    internal class NikiScript
    {
        public static IntPtr _printCallback_ns__3P6AXPEAXW4PrintLevel_1_PEBD_ZEA { get; }
        public static IntPtr _pPrintCallbackData_ns__3PEAXEA { get; }
        static NikiScript()
        {
            var path = "NikiScript";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _printCallback_ns__3P6AXPEAXW4PrintLevel_1_PEBD_ZEA = CppSharp.SymbolResolver.ResolveSymbol(image, "?printCallback@ns@@3P6AXPEAXW4PrintLevel@1@PEBD@ZEA");
            _pPrintCallbackData_ns__3PEAXEA = CppSharp.SymbolResolver.ResolveSymbol(image, "?pPrintCallbackData@ns@@3PEAXEA");
        }
    }
}

namespace Std
{
    namespace Vector
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector_____N_ns_S_Command___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____N_ns_S_Command___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____N_ns_S_Command___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1
        {
            internal global::Std.ListVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1
        {
            internal global::Std.ListVal.__Internal _Myval2;
        }
    }

}
namespace Std
{
    namespace UnorderedMap
    {
        [StructLayout(LayoutKind.Sequential, Size = 64, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unordered_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_
        {
            internal global::Std.UmapTraits.__Internalc__N_std_S__Umap_traits____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S__Uhash_compare__S0____N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3__Vb0 _Traitsobj;
            internal global::Std.List.__Internalc__N_std_S_list____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S_allocator__S0_ _List;
            internal global::Std.HashVec.__Internalc__N_std_S__Hash_vec____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable _Vec;
            internal ulong _Mask;
            internal ulong _Maxidx;
        }

        [StructLayout(LayoutKind.Sequential, Size = 64, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unordered_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_
        {
            internal global::Std.UmapTraits.__Internalc__N_std_S__Umap_traits____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S__Uhash_compare__S0____N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3__Vb0 _Traitsobj;
            internal global::Std.List.__Internalc__N_std_S_list____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S_allocator__S0_ _List;
            internal global::Std.HashVec.__Internalc__N_std_S__Hash_vec____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command _Vec;
            internal ulong _Mask;
            internal ulong _Maxidx;
        }
    }

}
namespace Std
{
    namespace UmapTraits
    {
        [StructLayout(LayoutKind.Sequential, Size = 4, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Umap_traits____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S__Uhash_compare__S0____N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3__Vb0
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_hash____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S__Compressed_pair____N_std_S_equal_to__S1__f_Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 4, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Umap_traits____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S__Uhash_compare__S0____N_std_S_hash__S0____N_std_S_equal_to__S0____N_std_S_allocator____N_std_S_pair__1S0__S3__Vb0
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_hash____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S__Compressed_pair____N_std_S_equal_to__S1__f_Vb1_Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace HashVec
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Hash_vec____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Hash_vec____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_unchecked_iterator____N_std_S__List_val____N_std_S__List_simple_types____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace List
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_list____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_ProgramVariable__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_list____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_ns_S_Command__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1 _Mypair;
        }
    }
}
